#! /usr/bin/env python3

import sys
import os
import re 
import readline
import cmd2
import argparse

import core.preferences as preferences
import core.vmconfig as vmconfig
import core.vminstance as vminstance
import core.vde2 as vde2
import core.session as session
import core.presentation as presentation
import utils.vagrant_utils as vagrant_utils


current_session = session.Session()
vminstances = list()
vde_switches = list()

def show_available_boxes():
    f = open('boxes.txt','r')
    print("Available boxes:")
    for line in f.read().split('\n'):
        print(line)

def update_vms_names():
    vms_list = vagrant_utils.list_vms()
    vms_names = vagrant_utils.list_vms_by_name(vms=vms_list)


def start():
    if current_session.load():
        vde_switches = current_session.vde_configs
        print("Current session:")
        print(current_session)
    update_vms_names()
    readline.read_init_file('readline_config.rc')
    app = CLI()
    app.cmdloop()


# TODO add history file to preferences.rc
history_file = os.path.expanduser('~/.pentesting_lab_history')
if not os.path.exists(history_file):
    with open(history_file, "w") as fobj:
        fobj.write("")
readline.read_history_file(history_file)
#TODO add atexit module
#atexit.register(readline.write_history_file, history_file)


class CLI(cmd2.Cmd):
    prompt = "> "
    #intro = "Welcome to the real world!"
    intro="""
 ________________ 
< Pentesting Lab >
 ---------------- 
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\\
                ||----w |
                ||     ||
"""

    def __init__(self):
        cmd2.Cmd.__init__(self)
        self.iface_cmd_strs = ['create','list']
        self.vm_cmd_strs = ['create','list']
        self.session_cmd_strs = ['create','save','load','show','start','destroy']
        self.exit_cmd_strs = ['soft','hard']


#### iface methods ####
    iface_parser = argparse.ArgumentParser()
    iface_parser.add_argument('cmd', help='= (create|list)')

    @cmd2.with_argparser(iface_parser)
    def do_iface(self,args):
        """Manage network interfaces"""
        if args.cmd == 'create':
            print("--- Creating net interface ---")
            name = input("Enter iface name: ")
            switch = vde2.VdeSwitch(name)
            switch.create_switch()
            current_session.add_iface(switch)
            vde_switches.append(switch)
        elif args.cmd == 'list':
            presentation.print_network_interfaces(current_session)


    def complete_iface(self, text, line, begidx, endidx):
        index_dict = \
            {
                1: self.iface_cmd_strs
            }
        return self.index_based_complete(text, line, begidx, endidx, index_dict=index_dict)


#### vm methods ####
    vm_parser = argparse.ArgumentParser()
    vm_parser.add_argument('cmd', help='= (create|list)')

    @cmd2.with_argparser(vm_parser)
    def do_vm(self,args):
        """Manage virtual machines"""
        if args.cmd == 'create':
            print("--- Creating machine ---")
            name = input("Enter name of vm: ")
            show_available_boxes()
            box = input("Enter name of the box: ")
            network_interfaces = list(filter(None, input("Enter network interfaces: ").split(" ")))
            packages = list(filter(None, input("Enter packages: ").split(" ")))
            playbooks = list(filter(None, input("Enter playbooks: ").split(" ")))
            #TODO: better parsing, multiple select
            config = vmconfig.VMConfig(name=name, box=box, gui=False, linked_clone=False,
                    network_interfaces=network_interfaces, packages=packages, playbooks=playbooks)
            current_session.add_vm(config)
        elif args.cmd == 'list':
            presentation.print_vms_general(current_session)


    def complete_vm(self, text, line, begidx, endidx):
        index_dict = \
            {
                1: self.vm_cmd_strs
            }
        return self.index_based_complete(text, line, begidx, endidx, index_dict=index_dict)


#### session methods ####
    session_parser = argparse.ArgumentParser()
    session_parser.add_argument('cmd', help='= (create|save|load|start|stop|destroy)')

    @cmd2.with_argparser(session_parser)
    def do_session(self,args):
        """Manage the session"""

        if args.cmd == 'create':
            # TODO
            pass
        elif args.cmd == 'load':
            print("Session file path (default ./sessions/session.cfg):", end="")
            path = input()
            if not path.strip():
                path = "./sessions/session.cfg"
            try:
                current_session.load(path=path)
                vde_switches = current_session.vde_configs
            except FileNotFoundError:
                pass
            #TODO
        elif args.cmd == 'save':
            current_session.save()
            #TODO
        elif args.cmd == 'show':
            current_session.show()
            #TODO
        elif args.cmd == 'start':
            for vmconfig in current_session.vm_configs:
                vminstances.append(vminstance.GuestMachine(vmconfig))
            for vm in vminstances:
                vm.setup()
                vm.up()
        elif args.cmd == 'stop':
            #TODO
            for vm in vminstances:
                vm.halt()
        elif args.cmd == 'destroy':
            #TODO
            pass


    def complete_session(self, text, line, begidx, endidx):
        index_dict = \
            {
                1: self.session_cmd_strs
            }
        return self.index_based_complete(text, line, begidx, endidx, index_dict=index_dict)


#### ssh methods ####
    ssh_parser = argparse.ArgumentParser()
    ssh_parser.add_argument('host', help='the host to ssh in')

    @cmd2.with_argparser(ssh_parser)
    def do_ssh(self,args):
        """SSH commands"""
        for vm in vminstances:
            if vm.config.name == args.host:
                vm.ssh()

    def complete_ssh(self, text, line, begidx, endidx):
        index_dict = \
            {
                1: [n.config.name for n in vminstances]
            }
        return self.index_based_complete(text, line, begidx, endidx, index_dict=index_dict)

#### exit methods ####
    exit_parser = argparse.ArgumentParser()
    exit_parser.add_argument('mode', nargs='?', default='soft', help='= hard if you want to destroy all the file created and kill all the processes')

    @cmd2.with_argparser(exit_parser)
    def do_exit(self,args):
        """EXIT"""
        if args.mode == 'hard':
            for vm in vminstances:
                vm.cleanup(destroy=True)
        elif args.mode == 'soft':
            for vm in vminstances:
                vm.cleanup(destroy=False)

        for switch in current_session.vde_configs:
            switch.halt_switch()
        sys.exit()

    def complete_exit(self, text, line, begidx, endidx):
        index_dict = \
            {
                1: self.exit_cmd_strs
            }
        return self.index_based_complete(text, line, begidx, endidx, index_dict=index_dict)

##TODO playbooks methods



#    def do_loadaverage(self, line):
#        with open('/proc/loadavg') as fobj:
#            data = fobj.read()
#        print(data)
#
#    def do_status(self, line):
#        if line:
#            resp = requests.get(line)
#            if resp.status_code == 200:
#                print(self.colorize("200", "green"))
#            else:
#                print(self.colorize(str(resp.status_code), "red"))
#
#    def do_alternativefacts(self, line):
#        print(self.colorize("Lies! Pure lies, and more lies.", "red"))
