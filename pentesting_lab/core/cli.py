#! /usr/bin/env python3

import sys
import os
import re 
import readline
import cmd2
import argparse

import pentesting_lab.core.preferences
import pentesting_lab.core.vmconfig
import pentesting_lab.core.vminstance
import pentesting_lab.core.vde2
import pentesting_lab.core.session
import pentesting_lab.core.presentation
import pentesting_lab.utils.vagrant_utils
from pentesting_lab.utils.user_input import prompt as user_input


current_session = pentesting_lab.core.session.Session()
vminstances = list()
vde_switches = list()

def show_available_boxes():
    f = open('pentesting_lab/configs/boxes.txt','r')
    print("Available boxes:")
    avail_boxes = f.read().split('\n')
    for line in avail_boxes:
        print(line)
    return avail_boxes

def update_vms_names():
    vms_list = pentesting_lab.utils.vagrant_utils.list_vms()
    vms_names = pentesting_lab.utils.vagrant_utils.list_vms_by_name(vms=vms_list)


def start():
    if current_session.load():
        vde_switches = current_session.vde_configs
        print("Current session:")
        print(current_session)
    update_vms_names()
    app = Cli()
    app.load_modules('modules')
    app.cmdloop()


# TODO add history file to preferences.rc
history_file = os.path.expanduser('~/.pentesting_lab_history')
if not os.path.exists(history_file):
    with open(history_file, "w") as fobj:
        fobj.write("")
readline.read_history_file(history_file)
#TODO add atexit module
#atexit.register(readline.write_history_file, history_file)


class Cli(cmd2.Cmd):
    prompt = "> "
    intro="""
 ________________ 
< Pentesting Lab >
 ---------------- 
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\\
                ||----w |
                ||     ||
"""
    modules = {}

    def __init__(self):
        cmd2.Cmd.__init__(self)
        self.iface_cmd_strs = ['create','list']
        self.vm_cmd_strs = ['create','list']
        self.session_cmd_strs = ['create','save','load','show','start','destroy']
        self.exit_cmd_strs = ['maintaining','destroying']

#### modules loading ####
    def _addloadedmodule(self, module_name, module_handle):
        self.modules[module_name] = module_handle

    def _delloadedmodule(self, module_name):
        del self.modules[module_name]

    def getloadedmodules(self):
        return(list(self.modules.keys()))

    def load_modules(self, modules_dir):
        for root, _, files in os.walk(modules_dir, topdown=False):
            for name in files:
                if name[-1] == 'c' or name[0] == '_':
                    continue
                self.load_module(root.replace('/','.') + "." + name[:-3])

    def load_module(self, module_name):
        gobj = self
        gcls = gobj.__class__
        handle = __import__(module_name)
        modules = [ i for i in dir(handle) if i[0] != '_']
        module = module_name.split('.')[1]
        modulehandle = getattr(handle, module)
        classnames = [ i for i in dir(modulehandle) if i[0] != '_']
        for cls in classnames:
            classhandle = getattr(modulehandle, cls)
            methodnames = [ i for i in dir(classhandle) if i[0] != '_']
            for method in methodnames:
                # Check for method override
                try:
                    getattr(gcls, method)
                    # is there any better way?
                    if method is "cmd2" or method is "argparse":
                        raise AttributeError
                    else:
                        raise(Exception("Override is not allowed (method:"+module_name+":"+method+")"))
                except AttributeError:
                    pass

                methodhandle = getattr(classhandle, method)
                setattr(gcls, method, methodhandle)
            gobj._addloadedmodule(cls, classhandle)

    def unload_module(self, module_name):
        gobj = self
        gcls = self.__class__

        classhandle = self.modules[module_name]
        methodnames = [ i for i in dir(classhandle) if i[0] != '_']
        for method in methodnames:
            methodhandle = getattr(classhandle, method)
            delattr(gcls, method)
        gobj._delloadedmodule(module_name)

#### iface methods ####
    iface_parser = argparse.ArgumentParser()
    iface_parser.add_argument('cmd', help='= (create|list)')


    @cmd2.with_argparser(iface_parser)
    def do_iface(self,args):
        """Manage network interfaces"""
        if args.cmd == 'create':
            print("--- Creating net interface ---")
            name = user_input(choice_msg='Enter iface name:')
            sniff = user_input(choice_msg='Sniff (true|false):',boolean=True)
            switch = pentesting_lab.core.vde2.VdeSwitch(name,sniff)
            switch.create_switch()
            current_session.add_iface(switch)
            vde_switches.append(switch)
        elif args.cmd == 'list':
            pentesting_lab.core.presentation.print_network_interfaces(current_session)


    def complete_iface(self, text, line, begidx, endidx):
        index_dict = \
            {
                1: self.iface_cmd_strs
            }
        return self.index_based_complete(text, line, begidx, endidx, index_dict=index_dict)


#### vm methods ####
    vm_parser = argparse.ArgumentParser()
    vm_parser.add_argument('cmd', help='= (create|list)')

    @cmd2.with_argparser(vm_parser)
    def do_vm(self,args):
        """Manage virtual machines"""
        if args.cmd == 'create':
            print("--- Creating machine ---")
            name = user_input(choice_msg="Enter name of vm: ")
            avail_boxes = show_available_boxes()
            box = user_input(choice_msg="Enter name of the box: ", choices=avail_boxes)
            network_interfaces = user_input(choice_msg="Enter network interfaces: ", ret_list=True, 
                    choices=[i.name for i in current_session.vde_configs], choices_only=True, accept_none=True)
            packages = user_input(choice_msg="Enter packages: ", ret_list=True, accept_none=True)
            playbooks = user_input(choice_msg="Enter playbooks: ", ret_list=True, accept_none=True)
            #TODO: better parsing, multiple select
            config = pentesting_lab.core.vmconfig.VMConfig(name=name, box=box, gui=False, linked_clone=False,
                    network_interfaces=network_interfaces, packages=packages, playbooks=playbooks)
            current_session.add_vm(config)
            print('Created vm {}'.format(name))
        elif args.cmd == 'list':
            pentesting_lab.core.presentation.print_vms_general(current_session)


    def complete_vm(self, text, line, begidx, endidx):
        index_dict = \
            {
                1: self.vm_cmd_strs
            }
        return self.index_based_complete(text, line, begidx, endidx, index_dict=index_dict)


#### session methods ####
    session_parser = argparse.ArgumentParser()
    session_parser.add_argument('cmd', help='= (create|save|load|start|stop|destroy)')

    @cmd2.with_argparser(session_parser)
    def do_session(self,args):
        """Manage the session"""

        if args.cmd == 'create':
            # TODO
            pass
        elif args.cmd == 'load':
            print("Session file path (default ./sessions/session.cfg):", end="")
            path = input()
            if not path.strip():
                path = "./sessions/session.cfg"
            try:
                current_session.load(path=path)
                vde_switches = current_session.vde_configs
            except FileNotFoundError:
                pass
            #TODO
        elif args.cmd == 'save':
            current_session.save()
            #TODO
        elif args.cmd == 'show':
            current_session.show()
            #TODO
        elif args.cmd == 'start':
            for vmconfig in current_session.vm_configs:
                vminstances.append(pentesting_lab.core.vminstance.GuestMachine(vmconfig))
            for vm in vminstances:
                vm.setup()
                vm.up()
        elif args.cmd == 'stop':
            #TODO
            for vm in vminstances:
                vm.halt()
        elif args.cmd == 'destroy':
            #TODO
            pass


    def complete_session(self, text, line, begidx, endidx):
        index_dict = \
            {
                1: self.session_cmd_strs
            }
        return self.index_based_complete(text, line, begidx, endidx, index_dict=index_dict)


#### ssh methods ####
    ssh_parser = argparse.ArgumentParser()
    ssh_parser.add_argument('host', help='the host to ssh in')

    @cmd2.with_argparser(ssh_parser)
    def do_ssh(self,args):
        """SSH commands"""
        for vm in vminstances:
            if vm.config.name == args.host:
                vm.ssh()

    def complete_ssh(self, text, line, begidx, endidx):
        index_dict = \
            {
                1: [n.config.name for n in vminstances]
            }
        return self.index_based_complete(text, line, begidx, endidx, index_dict=index_dict)

#### exit methods ####
    exit_parser = argparse.ArgumentParser()
    exit_parser.add_argument('mode', nargs='?', default='maintaining', help='= destroying if you want to destroy all the file created and kill all the processes')

    @cmd2.with_argparser(exit_parser)
    def do_exit(self,args):
        """EXIT"""
        if args.mode == 'destroying':
            for vm in vminstances:
                vm.cleanup(destroy=True)
        elif args.mode == 'maintaining':
            for vm in vminstances:
                vm.cleanup(destroy=False)

        for switch in current_session.vde_configs:
            switch.halt_switch()
        sys.exit()

    def complete_exit(self, text, line, begidx, endidx):
        index_dict = \
            {
                1: self.exit_cmd_strs
            }
        return self.index_based_complete(text, line, begidx, endidx, index_dict=index_dict)

##TODO playbooks methods



#    def do_loadaverage(self, line):
#        with open('/proc/loadavg') as fobj:
#            data = fobj.read()
#        print(data)
#
#    def do_status(self, line):
#        if line:
#            resp = requests.get(line)
#            if resp.status_code == 200:
#                print(self.colorize("200", "green"))
#            else:
#                print(self.colorize(str(resp.status_code), "red"))
#
#    def do_alternativefacts(self, line):
#        print(self.colorize("Lies! Pure lies, and more lies.", "red"))
